'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _restleError = require('restle-error');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _helpersCheckFilters = require('./helpers/check-filters');

var _helpersCheckFilters2 = _interopRequireDefault(_helpersCheckFilters);

var _helpersCheckIds = require('./helpers/check-ids');

var _helpersCheckIds2 = _interopRequireDefault(_helpersCheckIds);

var _helpersApplySort = require('./helpers/apply-sort');

var _helpersApplySort2 = _interopRequireDefault(_helpersApplySort);

var _helpersApplyFields = require('./helpers/apply-fields');

var _helpersApplyFields2 = _interopRequireDefault(_helpersApplyFields);

/**
 * The Adapter class is the interface between the persistence layer and Restle.
 * Adapter's responsibility is to retrieve basic json from the persistence layer,
 * and sideload relationships. The retrieved json must have a primary key.
 *
 * ```js
 * // stored in persistence layer
 * {
 *   id: 1,
 *   name: 'Jimmy John',
 *   pets: [ 1, 2 ],
 *   company: 4
 * }
 *
 * // the adapter needs to return
 * {
 *   id: 1,
 *   name: 'Jimmy John',
 *   pets: [{
 *     id: 1,
 *     name: 'Spot'
 *   }, {
 *     id: 2,
 *     name: 'Lucy'
 *   }],
 *   company: { id: 5, industry: 'electronics' }
 * }
 * ```
 *
 * Restle will provide the necessary methods with a Restle.Model class, which
 * includes all attribute and relationship information necessary for properly
 * sideloading records.
 *
 * Currently required methods: find, populate, retrieve, findRecord, create, update, delete.
 * TODO: establish required methods, eliminate lodash dependency, standardize error http codes
 *
 * @class
 */

var Adapter = (function () {
  function Adapter() {
    var store = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    _classCallCheck(this, Adapter);

    this.store = store;
  }

  /**
   * Connect to the persistence layer.
   *
   * @return {Promise}
   */

  _createClass(Adapter, [{
    key: 'connect',
    value: function connect() {
      return _bluebird2['default'].resolve(true);
    }

    /**
     * Disconnect from the persistence layer.
     *
     * @return {Promise}
     */
  }, {
    key: 'disconnect',
    value: function disconnect() {
      return _bluebird2['default'].resolve(true);
    }

    /**
     * This method populates a record with sideloaded relationships.
     *
     * @param {Model} model
     * @param {Object} data
     * @return {Object}
     */
  }, {
    key: 'populate',
    value: function populate(model, data) {
      // TODO: throw error if can't find resource with id, otherwise serializer breaks
      var relationships = model.relationships;

      var record = _lodash2['default'].clone(data);
      var relatedAdapter = undefined,
          relatedModel = undefined;

      for (var field in record) {
        if (!(field in relationships)) continue;

        relatedModel = relationships[field].model;
        relatedAdapter = relatedModel.adapter;
        record[field] = relatedAdapter.retrieve(relatedModel, record[field]);
      }

      return _bluebird2['default'].props(record);
    }

    /**
     * This method retrieves many records from the persistence layer. The method
     * must perform necessary pagination, filtering, inclusion, and sparse fieldsets
     * as defined by the JSON API spec (www.jsonapi.org).
     *
     * This method must return an array of sideloaded JSON records, and the array
     * must have a 'count' property indicating the total number of records before
     * pagination.
     *
     * @param {Model} Model
     * @param {Object} query
     * @return {Promise}
     */

  }, {
    key: 'find',
    value: function find(model) {
      var _this = this;

      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

      if (undefined === model) throw new TypeError('Model cannot be undefined.');

      if (undefined === model.type) throw new TypeError('Model type cannot be undefined.');

      var type = model.type;
      var store = this.store[type] || [];

      // filters
      var records = _lodash2['default'].clone(store, true).filter(function (record) {
        if ('ids' in options) if (!(0, _helpersCheckIds2['default'])(options.ids, record)) return false;

        if ('filter' in options) if (!(0, _helpersCheckFilters2['default'])(options.filter, record)) return false;

        return true;
      });

      // paginate
      var _records = records;
      var count = _records.length;

      if ('page' in options) {
        var _options$page = options.page;
        var offset = _options$page.offset;
        var limit = _options$page.limit;

        records = records.slice(offset || 0, (offset || 0) + (limit || count));
      }

      // sort and fields
      if ('sort' in options) (0, _helpersApplySort2['default'])(options.sort, records);

      if ('fields' in options) (0, _helpersApplyFields2['default'])(options.fields, records);

      // populate results
      var results = records.map(function (record) {
        return _this.populate(model, record);
      });

      return _bluebird2['default'].all(results).then(function (resolved) {
        resolved.count = count;
        return _bluebird2['default'].resolve(resolved);
      });
    }

    /**
     * This method retrieves pure records from the persistence layer with matching
     * ids as 'ids', or all records if `ids` is undefined.
     *
     * @param {Model} model
     * @param {Array|Value|undefined} ids
     */
  }, {
    key: 'retrieve',
    value: function retrieve(model, ids) {
      if (undefined === model) throw new TypeError('Model cannot be undefined.');

      if (undefined === model.type) throw new TypeError('Model type cannot be undefined.');

      if (undefined === ids) return _bluebird2['default'].resolve(this.store[model.type] || []);

      var isMany = Array.isArray(ids);

      // ensure ids is an array
      ids = isMany ? ids : [ids];

      // map to ids to numbers
      ids = ids.map(function (id) {
        return Number(id);
      });

      // retrieve records
      var type = model.type;
      var store = this.store[type] || [];
      var records = store.filter(function (record) {
        return (0, _helpersCheckIds2['default'])(ids, record);
      });

      return _bluebird2['default'].resolve(isMany ? records : records[0]);
    }

    /**
     * This method retrieves a single record from the persistence layer.
     *
     * @param {Model} Model
     * @param {String} id
     * @return {Promise}
     */
  }, {
    key: 'findRecord',
    value: function findRecord(model, id) {
      if (undefined === model) throw new TypeError('Model cannot be undefined.');

      if (undefined === model.type) throw new TypeError('Model type cannot be undefined.');

      var type = model.type;
      var record = _lodash2['default'].find(this.store[type], { id: Number(id) });

      // reject if resource not found
      if (undefined === record) return _bluebird2['default'].reject(new _restleError.NotFoundError({ type: type, id: id }));

      return _bluebird2['default'].resolve(this.populate(model, record));
    }

    /**
     * This method creates a record on the persistence layer. This method's
     * responsibility is to add the record then return the sideloaded json.
     *
     * @param {Model} Model
     * @param {Object} data
     * @return {Promise}
     */
  }, {
    key: 'create',
    value: function create(model, data) {
      var _this2 = this;

      if (undefined === model) throw new TypeError('Model cannot be undefined.');

      if (undefined === model.type) throw new TypeError('Model type cannot be undefined.');

      var type = model.type;

      // initialize the record store
      if (!(type in this.store)) this.store[type] = [];

      // increment the id
      var length = this.store[type].length;
      data.id = ++length;

      // create the resource
      this.store[type].push(data);

      return new _bluebird2['default'](function (resolve) {
        _this2.populate(model, data).then(function (record) {
          return resolve(record);
        });
      });
    }
  }, {
    key: 'update',
    value: function update(model, id, _update) {
      var _this3 = this;

      if (undefined === model) throw new TypeError('Model cannot be undefined.');

      if (undefined === model.type) throw new TypeError('Model type cannot be undefined.');

      var type = model.type;

      if (!(type in this.store)) return _bluebird2['default'].resolve(false);

      var store = this.store[type];
      var record = _lodash2['default'].find(store, { id: Number(id) });

      // reject if resource not found
      if (undefined === record) return _bluebird2['default'].reject(new _restleError.NotFoundError({ type: type, id: id }));

      // update the store
      store.splice(--id, 1, Object.assign(record, _update));

      return new _bluebird2['default'](function (resolve) {
        _this3.populate(model, record).then(function (resolved) {
          return resolve(resolved);
        });
      });
    }
  }, {
    key: 'delete',
    value: function _delete(model, id) {
      if (undefined === model) throw new TypeError('Model cannot be undefined.');

      if (undefined === model.type) throw new TypeError('Model type cannot be undefined.');

      var type = model.type;

      if (!(type in this.store)) return _bluebird2['default'].resolve(false);

      var store = this.store[type];
      var resource = _lodash2['default'].find(store, { id: Number(id) });

      // reject if resource not found
      if (undefined === resource) return _bluebird2['default'].reject(new _restleError.NotFoundError({ type: type, id: id }));

      // remove resource with matching id
      _lodash2['default'].remove(this.store[type], function (resource) {
        return Number(resource.id) === Number(id);
      });

      return _bluebird2['default'].resolve(true);
    }
  }]);

  return Adapter;
})();

exports['default'] = Adapter;
module.exports = exports['default'];